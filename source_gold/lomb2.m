function [freqs,alphas,alph,lineat,sigfreqs,sigpowers]=lomb2(inputdata,dupe_elim,fhi,ofac,is_plot)
% LOMBSCARGLE(INPUTDATA, DUPE_ELIM) performs a Lomb-Scargle periodogram (spectral) analysis on an n x 2 matrix of data 
% (inputdata = x(i),y(i)) that are not necessarily evenly spaced. (For evenly spaced data, more traditional
% Fourier-based spectral methods may be more appropriate.)
% 
% DUPE_ELIM (= 0 or 1) is an optional argument that 
% will prompt the program (if dupe_elim == 1) to eliminate duplicated samples from the analysis.
% The default value is 0.

% This program will plot and spectrally analyze the input data, and then plot the power spectrum of the data.
% The program is also capable of overlaying a signal of known frequency and amplitude; this may be helpful for
% spectral calibration. The resulting spectrum plot will also include significance levels. Finally, the program
% will reconstruct a plot of frequencies determined to be "significant" (at alpha = 0.05); for this reconstruction,
% frequencies within 5% of the calibration signal (if used) will be discarded. Significant frequencies and powers
% are written to the MATLAB command window.
%
% (This program is based on a Lomb-Scargle implementation in Press, Teukolsky, et al. Numerical Recipes,
% "Spectral Analysis of Unevenly Sampled Data." Use of this program requires an understanding of the
% Press/Teukolsky implementation, inculding the usage of hifac and ofac variables. The user is referred 
% to that source for a thorough discussion of the algorithms. In addition, the references cited in 
% Press/Teukolsky are quite helpful--particularly Scargle 1982, and Horne and Baliunas, 1986.)
%
% Note that there is an over-reliance in this code on global variables, and that no attempts have been made
% to vectorize for loops or to optimize the implementation. Perhaps in the next version....
%
% An optional file (INPUTTOLOMB.M) is also available for download, and includes code for easily generating 
% test data with known frequencies and amplitudes. This file is helpful for users trying to understand the output
% generated by lombscargle.
%
% Written by Brett Shoelson, Ph.D.
% 3/1/1999. Last modification: 10/25/01.

global cal calamp calfreq creationdate dataid datamatrix effm ep freqs hifac info jmax lines n ...
	nmax nout np nuhifac prob px py reg regnum s sigfreqs sigpowers tmax tmin win wintype x y

if nargin == 0
	error('Requires at least one input argument comprising n x 2 data matrix to analyze.');
elseif nargin == 1
	dupe_elim = 0;
end

if size(inputdata,2) ~= 2
	error('Input data must be an n x 2 matrix of numbers.')
end
lines=1;
numin=size(inputdata,1);
freqs=[];sigfreqs=[];brkvals=[];freqsofint=[];sigpositions=[];funcper=[];sigpowers=[];np=0;
creationdate=date;
x=inputdata(:,1);
y=inputdata(:,2);
tmin=min(x);
tmax=max(x);
n=length(x);
period(fhi,ofac);
%GENERATE TABLE OF PROBABILI`TIES
%Generating expytable.
expytable=exp(-freqs(:,2));
%Generating corresponding alpha values.
alphas=1-(1-expytable).^effm;
%Correcting for alpha = 0. (This ensures unique values in "highly significant" regions.)
for i=1:length(alphas)
	if alphas(i)==0
		alphas(i)=rand/1e20;
	end
end
% PLOT AND OUTPUT POWER

%CALCULATE GIVEN SIGNIFICANCE LEVELS FOR GRAPH
alph=[0.005 0.05 0.5];
lineat=log(1./(1-(1-alph).^(1/effm)));

if ~isempty(freqs) && is_plot
	%CREATE SPECTRUM FIGURE
	powerfig=figure('position',get(0,'screensize'),'name','Power Spectrum','NumberTitle','off');
	plot(freqs(:,1),freqs(:,2),'color','k');
	spectimage=gca;
	axis([0 fhi 0 1.1*max(freqs(:,2))]);
	set(gca,'Fontsize',8);
	xlabel('Frequency (Hz)');ylabel('Power');
	
	
	%CALCULATE GIVEN SIGNIFICANCE LEVELS FOR GRAPH
	alph=[0.005 0.05 0.5];
	lineat=log(1./(1-(1-alph).^(1/effm)));
	
	%PROBABILITY LINES and LABELS
	for i=1:length(alph)
		line([freqs(1,1),0.85*fhi],[lineat(i),lineat(i)],'color','black','linewidth',i/5,'linestyle','-.');
		text(0.87*fhi,lineat(i),['a = ' num2str(alph(i))],'fontsize',8,'fontname','symbol');
	end
	
	%DETERMINE WHICH FREQUENCIES ARE SIGNIFICANT
	fvals=find(alphas<=0.5)';
	freqsofint=freqs(fvals,1)';
	lenstring=length(freqsofint)-1;
	for i=1:length(freqsofint)-1
		%fprintf('Checking frequency %i of %i for significance.\n',i,lenstring);
		if freqsofint(i)>=freqsofint(i+1)
			freqsofint=freqsofint(1:i);
		end
	end
	alphasofint=alphas(fvals,1)';
	
	%FIND POSITIONS OF BREAKS IN FVALS (FOR DATA CLUSTERING)
	for i=1:length(fvals)-1
		if fvals(i)~=fvals(i+1)-1
			brkvals=[brkvals i];
		end
	end
	brkvals=[brkvals length(fvals)];
	
	%LOCATE SIGNIFICANT FREQUENCIES
	for i=1:length(brkvals)
		if i==1
			minalph=min(alphasofint(1:brkvals(1)));
			sigfreqs=[sigfreqs freqsofint(alphasofint==minalph)];
		else
			minalph=min(alphasofint(brkvals(i-1)+1:brkvals(i)));
			sigfreqs=[sigfreqs freqsofint(alphasofint==minalph)];
		end %if i=1;
	end %for i=1:...
	%END LOCATE
	
	%POWER AT SIGNIFICANT FREQUENCIES
	for i=1:length(sigfreqs)
		sigpositions=[sigpositions find(freqs(:,1)==sigfreqs(i))];
	end
	sigpowers=freqs(sigpositions,2)';
	if ~isempty(sigfreqs)
		fprintf([        '\n\nSignificant frequencies (in Hz) at ',num2str(sigfreqs)]);
		info{lines}=sprintf(['Significant frequencies at         ',num2str(sigfreqs)]);
		lines=lines+1;
		fprintf([          '\nCorresponding powers:              ',num2str(sigpowers)]);
		info{lines}=sprintf(['Corresponding powers:              ',num2str(sigpowers)]);
		lines=lines+1;
	else
		fprintf('\nNo significant frequencies found.\n');
		info{lines}=sprintf('No significant frequencies found.');
		lines=lines+1;
    end
end
return
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%SUBFUNCTIONS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function period(fhi,ofac)
global arg ave c cc cal calamp calfreq cwtau effm ep expy freqs hifac info ival jmax jval...
	lines n nmax nout np nudata nuhifac nuofac nux nuy pnow prob px py pymax regnum ...
results s ss sumc sumcy sums sumsh sumsy swtau tmax tmin variance wi win wintype wpi wpr wr wtau...
wtemp x xave xdif xmax xmin y yy 

%np = number of frequencies examined (= length of output freqs file)
%ofac = oversampling parameter (typically >= 4 for best results)
%hifac = input parameter defined as fhi/fc, where:
%fhi is the highest frequency examined, and
%fc is the Nyquist frequency (=N/(2T)).
hifac=fhi*2*(tmax-tmin)/n;
np=ofac*hifac*n*0.5;
nout=floor(0.5*ofac*hifac*n);
ave=mean(y);
variance=var(y);
xmin=tmin;
xmax=tmax;
xdif=xmax-xmin;
xave=0.5*(xmax+xmin);
pymax=0;
pnow=1/(xdif*ofac);
for jval=1:n
	arg=2*pi*((x(jval)-xave)*pnow);
	wpr(jval)=-2*sin(0.5*arg)^2;
	wpi(jval)=sin(arg);
	wr(jval)=cos(arg);
	wi(jval)=wpi(jval);
end
for ival=1:nout
	px(ival)=pnow;
	sumsh=0;
	sumc=0;
	for jval=1:n
		c=wr(jval);
		s=wi(jval);
		sumsh=sumsh+s*c;
		sumc=sumc+(c-s)*(c+s);
	end
	wtau=0.5*atan2(2*sumsh,sumc);
	swtau=sin(wtau);
	cwtau=cos(wtau);
	sums=0;
	sumc=0;
	sumsy=0;
	sumcy=0;
	for jval=1:n
		s=wi(jval);
		c=wr(jval);
		ss=s*cwtau-c*swtau;
		cc=c*cwtau+s*swtau;
		sums=sums+ss^2;
		sumc=sumc+cc^2;
		yy=y(jval)-ave;
		sumsy=sumsy+yy*ss;
		sumcy=sumcy+yy*cc;
		wtemp=wr(jval);
		wr(jval)=(wr(jval)*wpr(jval)-wi(jval)*wpi(jval))+wr(jval);
		wi(jval)=(wi(jval)*wpr(jval)+wtemp*wpi(jval))+wi(jval);
	end
% 	py(ival)=0.5*(sumcy^2/sumc+sumsy^2/sums)/variance;
    py(ival)=(sumcy^2/sumc+sumsy^2/sums); 
	%WRITE OUTPUT
	freqs(ival,1)=px(ival);
	freqs(ival,2)=py(ival);
	pnow=pnow+1/(ofac*xdif);
end
pymax=max(py);
jmax=find(py==pymax);
expy=exp(-pymax);
%effm is an estimate of the number of *independent* frequencies
effm=2*nout/ofac;
if ~isempty(effm) & effm~=0
	prob=1-(1-expy)^effm;	
	%STORE RESULTS
	results={pymax px(jmax) prob ofac hifac n cal calamp calfreq win wintype nout fhi};
else
	fprintf('period.m: No frequencies to analyze.');
end 
return